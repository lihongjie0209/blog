<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="李宏杰的博客">
<meta property="og:url" content="https://lihongjie0209.github.io/index.html">
<meta property="og:site_name" content="李宏杰的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李宏杰的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lihongjie0209.github.io/"/>





  <title>李宏杰的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李宏杰的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/11/03/JVM之类文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/03/JVM之类文件/" itemprop="url">JVM之类文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T22:32:01+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h2><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>用于表示Java的类文件, 在类文件的前四个字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cafe babe</span><br></pre></td></tr></table></figure>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>魔数之后的后四个字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0034 表示的的是JDK1.8</span><br></pre></td></tr></table></figure>
<h3 id="常量池大小"><a href="#常量池大小" class="headerlink" title="常量池大小"></a>常量池大小</h3><p>版本号之后的两个字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0036 表示有53个常量</span><br></pre></td></tr></table></figure>
<h3 id="常量池-大小依赖于源代码"><a href="#常量池-大小依赖于源代码" class="headerlink" title="常量池(大小依赖于源代码)"></a>常量池(大小依赖于源代码)</h3><ol>
<li>源代码中的常量, 如字符串</li>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符</li>
</ol>
<p>类, 字段, 方法都是由字符串变量组合而成的.</p>
<p>比如说我们有以下常量池, 反编译<code>HelloWorld.class</code> 得到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line"> #1 = Methodref          #7.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"> #3 = String             #27            // hello world</span><br><span class="line"> #4 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"> #5 = Fieldref           #6.#30         // cn/lihongjie/HelloWorld.i:I</span><br><span class="line"> #6 = Class              #31            // cn/lihongjie/HelloWorld</span><br><span class="line"> #7 = Class              #32            // java/lang/Object</span><br><span class="line"> #8 = Utf8               i</span><br><span class="line"> #9 = Utf8               I</span><br><span class="line">#10 = Utf8               &lt;init&gt;</span><br><span class="line">#11 = Utf8               ()V</span><br><span class="line">#12 = Utf8               Code</span><br><span class="line">#13 = Utf8               LineNumberTable</span><br><span class="line">#14 = Utf8               LocalVariableTable</span><br><span class="line">#15 = Utf8               this</span><br><span class="line">#16 = Utf8               Lcn/lihongjie/HelloWorld;</span><br><span class="line">#17 = Utf8               main</span><br><span class="line">#18 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">#19 = Utf8               args</span><br><span class="line">#20 = Utf8               [Ljava/lang/String;</span><br><span class="line">#21 = Utf8               &lt;clinit&gt;</span><br><span class="line">#22 = Utf8               SourceFile</span><br><span class="line">#23 = Utf8               HelloWorld.java</span><br><span class="line">#24 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#25 = Class              #33            // java/lang/System</span><br><span class="line">#26 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">#27 = Utf8               hello world</span><br><span class="line">#28 = Class              #36            // java/io/PrintStream</span><br><span class="line">#29 = NameAndType        #37:#38        // println:(Ljava/lang/String;)V</span><br><span class="line">#30 = NameAndType        #8:#9          // i:I</span><br><span class="line">#31 = Utf8               cn/lihongjie/HelloWorld</span><br><span class="line">#32 = Utf8               java/lang/Object</span><br><span class="line">#33 = Utf8               java/lang/System</span><br><span class="line">#34 = Utf8               out</span><br><span class="line">#35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">#36 = Utf8               java/io/PrintStream</span><br><span class="line">#37 = Utf8               println</span><br><span class="line">#38 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>
<p>我们拿其中的<code>println</code>进行说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-11-4/70851148.jpg" alt=""></p>
<h3 id="类文件访问权限"><a href="#类文件访问权限" class="headerlink" title="类文件访问权限"></a>类文件访问权限</h3><ol>
<li><p>类文件的类型(ACC_${TYPE}  这个在源码反编译的时候一眼就可以看出来)</p>
<ol>
<li>接口</li>
<li>抽象类</li>
<li>注解</li>
<li>枚举</li>
</ol>
</li>
<li><p>类文件的访问权限</p>
<ol>
<li>public</li>
<li>final</li>
</ol>
</li>
</ol>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><ol>
<li>this_class 当前类</li>
<li>super_class 父类</li>
<li>interface 实现的接口</li>
</ol>
<h3 id="字段集合"><a href="#字段集合" class="headerlink" title="字段集合"></a>字段集合</h3><ol>
<li>标志位(权限位)<ol>
<li>public</li>
<li>static</li>
<li>private</li>
<li>…..</li>
</ol>
</li>
<li>字段信息<ol>
<li>字段名</li>
<li>字段类型</li>
</ol>
</li>
</ol>
<h3 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h3><ol>
<li>标志位</li>
<li>名称</li>
<li>描述符</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类文件中的, 所有的信息都存储在常量池中, 而JVM指令只需要以常量池中的数据作为参数运行就可以了,</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/11/02/JVM之VisualVM连接远程服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/02/JVM之VisualVM连接远程服务器/" itemprop="url">JVM之VisualVM连接远程服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-02T14:42:14+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何连接到远程服务器"><a href="#如何连接到远程服务器" class="headerlink" title="如何连接到远程服务器"></a>如何连接到远程服务器</h1><h1 id="常用的方法-不推荐"><a href="#常用的方法-不推荐" class="headerlink" title="常用的方法(不推荐)"></a>常用的方法(不推荐)</h1><h2 id="JStatD"><a href="#JStatD" class="headerlink" title="JStatD"></a>JStatD</h2><blockquote>
<p>jstatd is a daemon that is distributed with JDK. You start it from the command line (it’s likely necessary to run it as the user running the target JVM or as root) on the target machine and VisualVM will contact it to fetch information about the remote JVMs.</p>
<ul>
<li>Advantages: Can connect to a running JVM, no need to start it with special parameters</li>
<li>Disadvantages: Much more limited monitoring capabilities (f.ex. no CPU usage monitoring, not possible to run the Sampler and/or take thread dumps).</li>
</ul>
</blockquote>
<p>我们可以在JDK自带的工具里面找到<code>JStatD</code>, 然后使用<code>VisualVM</code>连接<code>JstatD</code>. </p>
<p>优点:</p>
<ol>
<li>JVM不必重启, 可以直接监控运行中的JVM</li>
</ol>
<p>缺点:</p>
<ol>
<li>由于没有侵入运行中的JVM, 所以可用的功能有限</li>
<li>需要服务器开放端口给<code>JstatD</code> 使用.</li>
</ol>
<h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><p>JVM的远程管理接口</p>
<p>优点:</p>
<ol>
<li>可以使用<code>VisualVM</code>的全部功能</li>
</ol>
<p>缺点:</p>
<ol>
<li><p>需要重启JVM, 使用以下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yourJavaCommand... </span><br><span class="line">-Dcom.sun.management.jmxremote </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false </span><br><span class="line">-Dcom.sun.management.jmxremote.port=1098</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要服务器开放<code>com.sun.management.jmxremote.port</code> 端口</p>
</li>
</ol>
<p>上述两种方法的共通特点就是需要开放服务器端口和重启JVM, 对于开发人员来说, 这两个都是比较困难的, 下面介绍的方法可以完全避开这两个动作.</p>
<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><ol>
<li>你可以SSH到你需要监控的服务器中</li>
<li>你有相应的权限去安装一些软件和重启SSH服务</li>
<li>你需要有一款Windows的X Server 软件</li>
</ol>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><p>当你和服务器建立SSH连接时, 你就可以借助这个SSH连接转发任意的TCP流量. 关于SSH隧道的原理可以参考这篇文章: </p>
<p><a href="https://www.ssh.com/ssh/tunneling/" target="_blank" rel="noopener">SSH TUNNEL</a></p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-11-2/75189828.jpg" alt=""></p>
<p>建立SSH隧道之后, 流量可以进行两个方向的流动:</p>
<ol>
<li><p>SSH Client -&gt; SSH Server</p>
<p>比如说: 你有一台WEB服务器, 上面有一个MYSQL实例在运行, 服务器开放了80端口对外进行服务, 现在你需要连接到MYSQL中去进行一些操作. 正常情况下这是不可能的, 因为服务器没有对外开放3306端口, 但是如果你可以SSH到这台服务器, 那么你就可以把你的MYSQL数据包借助SSH隧道发送到服务器. 常用的MYSQL客户端Navicat就提供这个功能.</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-11-2/11888416.jpg" alt=""></p>
</li>
<li><p>SSH Server -&gt; SSH Client</p>
<p>这个就是我们今天的主角, 借助SSH隧道, 我们可以把服务器的流量转发的客户端. 要讲这个我们首先需要了解Linux的GUI的工作原理.</p>
</li>
</ol>
<h2 id="X-Window-System"><a href="#X-Window-System" class="headerlink" title="X Window System"></a>X Window System</h2><p>X 常用于Linux的GUI, 而VisualVM就是一个GUI程序, 要在远程服务器启动VisualVM, 我们必须了解X的运行原理.</p>
<p>首先X是一个CS架构的程序, 由服务器和客户端组成.</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-11-2/70863260.jpg" alt=""></p>
<p>用户输入事件由操作系统传递给X Server, 而GUI程序从X Server中获取这些事件,并把UI变化传递给X Server, 最后X Server把这些UI展示给用户.</p>
<p>需要注意的有两点:</p>
<ol>
<li>X Server 负责渲染UI, 也就是说如果XServer在我们本地服务器, 那么我们就可以在本地服务器中显示UI</li>
<li>X Client 负责响应事件, 并发送请求给X Server 进行UI更新</li>
</ol>
<p>有上面的两个技术, 那么我们就可以在本地运行远程服务器中的UI程序, 比如说VisualVM, 整体的架构如下:</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-11-2/60369001.jpg" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="服务器开启-X-Client流量转发"><a href="#服务器开启-X-Client流量转发" class="headerlink" title="服务器开启 X Client流量转发"></a>服务器开启 X Client流量转发</h2><ol>
<li><p>编辑<code>/etc/ssh/sshd_config</code>, 修改配置项为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##启用X11 Forwarding</span><br><span class="line">X11Forwarding yes</span><br></pre></td></tr></table></figure>
<p>修改之后重启sshd服务</p>
<p>CentOS6  <code>service sshd restart</code></p>
<p>CentOS7 <code>systemctl restart sshd</code></p>
<p>重启之后可以看到sshd会监听本地的6010端口, 也就是X Server的端口, 当这个端口收到流量时会转发给SSH的客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_45_207_centos ~]# netstat -anltp | grep ssh</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      22375/sshd          </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      22487/sshd: root@pt </span><br><span class="line">tcp        0     52 10.104.45.207:22        140.240.17.92:35490     ESTABLISHED 22487/sshd: root@pt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="服务器安装-X-Client-依赖"><a href="#服务器安装-X-Client-依赖" class="headerlink" title="服务器安装 X Client 依赖"></a>服务器安装 X Client 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install xorg-x11-apps # 这个包有我们需要的依赖</span><br><span class="line"></span><br><span class="line">	Dep-Install libXaw-1.0.13-4.el7.x86_64     @os</span><br><span class="line">    Dep-Install libXmu-1.1.2-2.el7.x86_64      @os</span><br><span class="line">    Dep-Install libXt-1.1.5-3.el7.x86_64       @os</span><br><span class="line">    Dep-Install libxkbfile-1.0.9-3.el7.x86_64  @os</span><br><span class="line">    Install     xorg-x11-apps-7.7-7.el7.x86_64 @os</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install xorg-x11-xauth # x client 和 server 的会话管理</span><br></pre></td></tr></table></figure>
<h2 id="客户端启动-X-Server服务器"><a href="#客户端启动-X-Server服务器" class="headerlink" title="客户端启动 X Server服务器"></a>客户端启动 X Server服务器</h2><p>X Server我使用的是X Manager 自带的.</p>
<h2 id="客户端转发-X-Client-流量到-X-Server服务器"><a href="#客户端转发-X-Client-流量到-X-Server服务器" class="headerlink" title="客户端转发 X Client 流量到 X Server服务器"></a>客户端转发 X Client 流量到 X Server服务器</h2><p><img src="D:\blog\source\_posts\assets\1541172879942.png" alt="1541172879942"></p>
<h2 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><p>进行上述操作之后, 理论上你就可以在本地环境中运行远程服务器的X Client 程序了, 下面是测试环节</p>
<h3 id="Cookie-测试"><a href="#Cookie-测试" class="headerlink" title="Cookie 测试"></a>Cookie 测试</h3><p>如果你成功的建立的X11 转发隧道, 那么登录服务器之后可以在服务器端查看到当前的会话Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_45_207_centos ~]# xauth list</span><br><span class="line">VM_45_207_centos/unix:10  MIT-MAGIC-COOKIE-1  895715dfbd457651d243e3744d3cf52b</span><br><span class="line">VM_45_207_centos/unix:11  MIT-MAGIC-COOKIE-1  892a667a2b427e12de87a75449ca73d8</span><br></pre></td></tr></table></figure>
<h3 id="X-app-测试"><a href="#X-app-测试" class="headerlink" title="X app 测试"></a>X app 测试</h3><p>可以使用X 自带的一些小程序来检测隧道是否建立, 比如说: <code>xclock</code></p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-11-2/28797689.jpg" alt=""></p>
<p>进行上述操作之后, 理论上来说你可以在本机中运行服务器的任何GUI程序, 包括Firefox, VisualVM.</p>
<h1 id="关于VisualVM的一些坑"><a href="#关于VisualVM的一些坑" class="headerlink" title="关于VisualVM的一些坑"></a>关于VisualVM的一些坑</h1><h2 id="运行没有响应"><a href="#运行没有响应" class="headerlink" title="运行没有响应"></a>运行没有响应</h2><p>运行VisualVM之后命令自动退出, 没有报错, 也没有日志. 遇到这种情况首先应该把日志打开, 然后根据日志的报错信息去排查. 命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./jvisualvm -J-Dnetbeans.logger.console=true</span><br></pre></td></tr></table></figure>
<h2 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h2><p>这个就需要安装中文字体了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;fonts&quot;</span><br></pre></td></tr></table></figure>
<p>当然这种安装方式可能会安装很多不必要的包, 你可以在网上找到只安装特定字体的教程, 这里就不再累述了.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/10/31/JVM之垃圾回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/10/31/JVM之垃圾回收/" itemprop="url">JVM之垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-31T20:02:12+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾回收需要解决的问题有三个:</p>
<ol>
<li>如何确定对象不再被引用</li>
<li>确定垃圾对象之后什么时候进行清理</li>
<li>采取什么清理策略</li>
</ol>
<h1 id="垃圾对象定位"><a href="#垃圾对象定位" class="headerlink" title="垃圾对象定位"></a>垃圾对象定位</h1><p>垃圾对象定位是垃圾回收的第一步, 只有在确定垃圾对象之后, 我们才能进行回收.</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>每一个对象都有一个标志位, 用于记录被引用的次数. 当次数为0时表示对象不再被使用, 那么就可以标记为垃圾对象.</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>简单</li>
<li>快速</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>无法解决循环引用的问题</li>
</ol>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在对象组成的图中, 每一个对象必须和关键的节点(ROOT)是连通的, 这样才能认为对象是存活的.</p>
<h1 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h1><p>垃圾清除算法就是把垃圾对象从内存中删除, 我们可以抽象的把垃圾清除的过程的认为是: 从一个数组中删除一部分元素.</p>
<h2 id="直接删除法"><a href="#直接删除法" class="headerlink" title="直接删除法"></a>直接删除法</h2><p>把数组中的元素直接删除</p>
<p>删除之前:</p>
<p>[✔✔✔✔✔✔✔✔✔✔✔✔✔✔✔✔]</p>
<p>删除之后:</p>
<p>[✔✔□□□✔✔□✔✔✔□□□✔✔✔]</p>
<p>可以很明显的发现内存的碎片化, 所以这个算法是不可接收的</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>在复制算法中, 需要有两个相同大小的内存块, 需要删除元素时, 把需要保留的元素复制到另外一个内存中</p>
<p>这个算法除了空间复杂度有点大之外没什么缺点.</p>
<p>适用于存活对象少的情况, 这种情况下复制次数少</p>
<h2 id="整理算法"><a href="#整理算法" class="headerlink" title="整理算法"></a>整理算法</h2><p>删除元素之后把内存整理一下, 就是我们常见的数组删除算法, 适用于存活对象多的情况.</p>
<h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><p>当需要触发GC时, 所有的线程必须中断才能准确的进行垃圾检测. 所以JVM在需要进行GC的时候会设置一个标志位, 所有的线程都会轮询这个标志位, 当发现需要进行GC的时候, 由线程自己进行中断, 当所有的线程都中断时, 也就发生了STW事件(除了垃圾回收线程之外没有线程在运行了).</p>
<h1 id="垃圾清除算法实现"><a href="#垃圾清除算法实现" class="headerlink" title="垃圾清除算法实现"></a>垃圾清除算法实现</h1><ol>
<li>并发垃圾收集器: 可以和用户线程一起运行的垃圾收集器</li>
<li>并行垃圾收集器: 可以使用多核的垃圾收集器</li>
<li>单体垃圾收集器: 一次性完成垃圾收集工作</li>
<li>渐进式垃圾收集器: 垃圾收集的过程分为多个步骤</li>
<li>保守垃圾收集器: 无法完全收集全部垃圾</li>
<li>准确垃圾收集: 可以完全收集垃圾</li>
<li>安全点: 线程执行过程中可以确定所有的栈上对象引用, 可以保证垃圾回收器准确运行</li>
</ol>
<h2 id="垃圾清除算法的一般原则"><a href="#垃圾清除算法的一般原则" class="headerlink" title="垃圾清除算法的一般原则"></a>垃圾清除算法的一般原则</h2><ol>
<li>年轻代通常使用单体(STW)的复制(对象存活几率小)垃圾回收算法.</li>
<li>老年代通常使用标记清除压缩算法, 对象存活率高. 通常是渐进式的垃圾回收算法.<ol>
<li>并发标记: 和用户线程一起工作(用户可能产生新的垃圾), 在第一遍工作结束之后, 可能需要再次检查一下</li>
<li>渐进式压缩碎片: 把内存分为不同的区域, 找到被引用最少的区域, 然后压缩</li>
</ol>
</li>
<li><strong>垃圾回收只能被延迟, 不能被取消</strong></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/10/31/JVM之内存分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/10/31/JVM之内存分类/" itemprop="url">JVM之内存分类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-31T10:14:06+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>是一个线程私有的内存区域, 每一个方法调用就会产生一个<code>stack frame</code>,  用于储存方法调用的各种信息</p>
<ol>
<li>局部变量表</li>
<li>操作数</li>
<li>方法出口</li>
</ol>
<p>如果一个线程中的<code>stack</code> 超过大小, 那么就会抛出<code>java.lang.StackOverflowError</code></p>
<p>可以通过 <code>-Xss</code> 参数调整<code>stack</code>的大小.</p>
<p>下面的代码默认的大小只能调用6000次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStackOverflow</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> stackCounter = <span class="number">0</span>;</span><br><span class="line">	empty(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">empty</span><span class="params">(<span class="keyword">int</span> counter)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"current stack counter is "</span> + String.valueOf(counter));</span><br><span class="line">	empty(counter + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是JVM中存储对象的内存, 所有线程共享, 是垃圾回收主要进行的区域. 在栈中创建的对象都会存储在堆中, 栈中只存储引用.</p>
<p>当堆中的内存空间耗尽时, 会抛出<code>java.lang.OutOfMemoryError</code></p>
<p>下面这段代码会导致OOM, 把堆大小调整的小一点可以快速的看到效果 <code>-Xmx10M -Xms10M</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOOM</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	LinkedList&lt;Object&gt; objects = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">		objects.add(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>在操作系统中, 这个区域被称为 <code>code</code> 也就是存储我们源代码的区域, 所有线程共享. 这个区域如果太小, 可能会导致以下问题:</p>
<ol>
<li>系统启动时抛出OOM, 因为系统启动时会加载很多类, 所以如果系统的类太多, 在启动时直接OOM</li>
<li>在系统运行时, 如果生成的动态代理类太多, 也会导致OOM</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/08/21/AVL树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/21/AVL树/" itemprop="url">AVL树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:37:22+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问: 什么是平衡二叉树 ?</p>
<blockquote>
<p>答: 对于任意一个节点, 左子树的右子树的高度差不能超过1</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/08/19/并查集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/19/并查集/" itemprop="url">并查集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-19T15:33:41+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问: 什么是并查集 ?</p>
<blockquote>
<p> 答 一组集合, 集合中的任意一个元素都只存在于一个集合中. 目的是提供一种高效的数据结构用于不相交集合的合并和查询.</p>
</blockquote>
<p>问: 怎么实现并查集 ?</p>
<blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速查找算法</td>
<td>使用数组表示集合, 每一个元素引用它所在的集合, 查找直接返回</td>
<td>查找快</td>
<td>合并需要修改引用</td>
</tr>
<tr>
<td>快速合并算法</td>
<td>使用树表示集合, 合并时把当前树的根节点的父节点指向调整一下, 查找时一直向上查询父节点.</td>
<td>查找快(树高有关系) &gt;&gt; 优化的话压缩树高</td>
<td>合并快</td>
</tr>
</tbody>
</table>
</blockquote>
<p>问: 怎么压缩树高?</p>
<blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>按树高大小合并, 小树合并到大树, 确保树高不增加</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/08/19/字典树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/19/字典树/" itemprop="url">字典树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-19T15:06:16+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问: 什么是字典树(前缀树)?</p>
<blockquote>
<p>答: 把树的节点替换为hash表, 类似于多级hash表</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-19/61906233.jpg" alt=""></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/08/19/优先队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/19/优先队列/" itemprop="url">优先队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-19T14:36:15+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问: 什么是优先队列 ?</p>
<blockquote>
<p>答: 一种泛化的队列, 普通队列的优先级都一样.</p>
</blockquote>
<p>问: 如何实现优先队列 ?</p>
<blockquote>
<table>
<thead>
<tr>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>每次出队查找最大元素</td>
<td>入队快</td>
<td>出队太慢</td>
</tr>
<tr>
<td>每次入队都维持队列的有序性</td>
<td>出队快</td>
<td>入队慢</td>
</tr>
<tr>
<td>堆</td>
<td>出队快</td>
<td>入队快</td>
</tr>
</tbody>
</table>
<p>前两种方法的问题在于对于队列来说, 我们只需要维护队首元素是优先级最高的就可以, 没必要对整个队列排序</p>
</blockquote>
<p>问: 什么是堆?</p>
<blockquote>
<p>答: 堆是完全二叉树, 其中任意子节点都要小于父节点</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-19/14699471.jpg" alt=""></p>
</blockquote>
<p>问: 添加和删除元素如何保证堆的性质 ?</p>
<blockquote>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1534661345420.png" alt="1534661345420"></p>
<p>每次添加元素都添加到数组的最后一位, 判断是否比它的父亲节点大, 如果比父亲节点大, 那么就交换, 接着判断.</p>
<p>每次删除元素, 首先用最后一个替代根节点, 保证完全二叉树的性质</p>
<p>然后开始下沉, 取两个子节点的最大值, 交换位置直到该节点满足了堆的性质</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1534661705536.png" alt="1534661705536"></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/08/16/算法-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/16/算法-一/" itemprop="url">算法(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-16T13:41:27+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问: 什么是算法 ?</p>
<blockquote>
<p>答: 把输入数据转化为输出数据的一个过程</p>
</blockquote>
<p>问: 什么是选择排序 ?</p>
<blockquote>
<p>答: 在待排序的数组中找到最小值,然后添加到一个排序好的数组中. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">SelectionSort</span><span class="params">(lst)</span>:</span></span><br><span class="line">&gt;     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)): // i 是已排序好的数组下一个空槽的下标</span><br><span class="line">&gt;         minIndex = i</span><br><span class="line">&gt;         <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(lst)): // 选出最小值</span><br><span class="line">&gt;             <span class="keyword">if</span> lst[minIndex] &gt; lst[j]:</span><br><span class="line">&gt;                 minIndex = j</span><br><span class="line">&gt;         tmp = lst[minIndex]   // 把最小值放到空槽中</span><br><span class="line">&gt;         lst[minIndex] = lst[i]</span><br><span class="line">&gt;         lst[i] = tmp</span><br><span class="line">&gt;     <span class="keyword">return</span> lst</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p>问: 什么是递归 ?</p>
<blockquote>
<p>答: 递归是一个循环依赖, 如果没有结束循环的条件, 那么就会无限的运行下去.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; // 使用递归计算阶乘</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(i)</span>:</span></span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&gt;     <span class="keyword">else</span>:</span><br><span class="line">&gt;         <span class="keyword">return</span> i * fact(i - <span class="number">1</span>)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>问: 快速排序的实现</p>
<blockquote>
<p>答:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(lst, start, end)</span>:</span></span><br><span class="line">&gt;         p = lst[start]</span><br><span class="line">&gt;         wall = start  // wall <span class="keyword">is</span> <span class="keyword">not</span> exist at start</span><br><span class="line">&gt;         <span class="keyword">for</span> current <span class="keyword">in</span> range(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">&gt;             <span class="keyword">if</span> lst[current] &lt; p:</span><br><span class="line">&gt;                 tmp = lst[wall + <span class="number">1</span>]</span><br><span class="line">&gt;                 lst[wall + <span class="number">1</span>] = lst[current]</span><br><span class="line">&gt;                 lst[current] = tmp</span><br><span class="line">&gt;                 wall = wall + <span class="number">1</span></span><br><span class="line">&gt;         tmp = lst[start]</span><br><span class="line">&gt;         lst[start] = lst[wall]</span><br><span class="line">&gt;         lst[wall] = tmp</span><br><span class="line">&gt;         <span class="keyword">return</span> wall</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">_QuickSort</span><span class="params">(lst, start, end)</span>:</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">if</span> (start &gt;= end):</span><br><span class="line">&gt;             <span class="keyword">return</span></span><br><span class="line">&gt;         <span class="keyword">else</span>:</span><br><span class="line">&gt;             p = partition(lst, start, end)</span><br><span class="line">&gt;             _QuickSort(lst, start, p - <span class="number">1</span>)</span><br><span class="line">&gt;             _QuickSort(lst, p + <span class="number">1</span>, end)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>问: 什么是动态规划 ?</p>
<blockquote>
<p>答: 就是递归, 但是动态规划会把大问题的解变为多个小问题的解, 同时缓存小问题的计算结果, 避免重复计算.</p>
<p>至于如何把大问题分成小问题那是需要专门做算法的人来处理, 一般程序猿不需要关系.</p>
</blockquote>
<p>问: 什么是贪婪算法?</p>
<blockquote>
<p>答: 解决问题的每步都选择局部最优解, 最终得到的结果是全局最优解</p>
</blockquote>
<p>问: 什么是NP完全问题?</p>
<blockquote>
<p>答; 需要求出所有的解才能解决的问题, 排列问题, 运行速度在问题规模达到一定程度之后非常慢</p>
</blockquote>
<p>问: 什么是散列表 ?</p>
<blockquote>
<p>答: 一个泛化的线性结构, 一个数组, 它的下标不再是数字, 可以是任意值.</p>
</blockquote>
<p>问: 如何解决散列表的冲突问题?</p>
<blockquote>
<p>答: 使用链表储存映射到同样键的数据</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lihongjie0209.github.io/blog/2018/08/13/OS之持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李宏杰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李宏杰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/13/OS之持久化/" itemprop="url">OS之持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-13T10:01:38+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问: IO设备是如何与操作系统进行通信的?</p>
<blockquote>
<p> 答: 通过总线</p>
</blockquote>
<p>问: 什么是总线?</p>
<blockquote>
<p>答: In <a href="https://en.wikipedia.org/wiki/Computer_architecture" target="_blank" rel="noopener">computer architecture</a>, a <strong>bus</strong><a href="https://en.wikipedia.org/wiki/Bus_(computing" target="_blank" rel="noopener">[1]</a>#cite_note-1) (a contraction of the Latin <em>omnibus</em>) is a communication system that transfers data between components inside a <a href="https://en.wikipedia.org/wiki/Computer" target="_blank" rel="noopener">computer</a>, or between computers. This expression covers all related hardware components (wire, optical fiber, etc.) and software, including communication protocols.<a href="https://en.wikipedia.org/wiki/Bus_(computing" target="_blank" rel="noopener">[2]</a>#cite_note-2) </p>
</blockquote>
<p>问: 为什么要设计多级总线架构 ?</p>
<blockquote>
<p>答: 多级总线针对的是不同IO设备所作出的优化, 低速设备连接到低速总线, 高速设备连接到高速总线</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-13/59736801.jpg" alt=""></p>
</blockquote>
<p>问: 一个IO设备的组成是什么?</p>
<blockquote>
<p> 答: 外部接口以及内部实现.</p>
<p><img src="http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-13/29166608.jpg" alt=""></p>
</blockquote>
<p>问: 操作系统如何与IO设备交互?</p>
<blockquote>
<p>答: </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>详细</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>PIO</td>
<td>轮询IO设备的状态并给command和data寄存器写入数据</td>
<td>性能问题</td>
</tr>
<tr>
<td>中断</td>
<td>把PIO中轮询改为中断,IO设备把状态推给OS</td>
<td>中断处理, 上下文切换, CPU读写IO</td>
</tr>
<tr>
<td>DMA</td>
<td>CPU不再读写IO, DMA直接把IO设备中的数据放到内存</td>
</tr>
</tbody>
</table>
</blockquote>
<p>问: 什么是RAID ?</p>
<blockquote>
<p>答:  At a high level, a RAID is very much a specialized computer system: it has a processor, memory,and disks; however,instead of running applications, it runs specialized software designed to operate the RAID.</p>
</blockquote>
<p>问: RAID解决了什么问题?</p>
<blockquote>
<p>答: 磁盘的可靠性和性能问题. 使用多快磁盘并行读写, 使用冗余磁盘确保数据不丢失.</p>
</blockquote>
<p>问: RAID是如何实现的 ?</p>
<blockquote>
<p>答: 对RAID的IO请求都会转化了对几个磁盘的IO请求(封装, 转发)</p>
</blockquote>
<p>问: RAID有哪些实现 ?</p>
<blockquote>
<p>答:</p>
<table>
<thead>
<tr>
<th>实现</th>
<th>容量(n为数量, N为容量)</th>
<th>可靠性</th>
<th>速度(单盘速度s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAID0</td>
<td>n x N</td>
<td>无</td>
<td>s * N</td>
</tr>
<tr>
<td>RAID1(镜像)</td>
<td>n * N / 2</td>
<td>可以损坏一块盘</td>
<td>和单个磁盘持平</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p>问: 什么是文件?</p>
<blockquote>
<p>答: inode, 提供了顺序和随机读写的接口. 文件头提供了初数据之外的全部信息.</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1534163323569.png" alt="1534163323569"></p>
</blockquote>
<p>问: 什么是文件夹?</p>
<blockquote>
<p>答: [{inode: “fileName”}]</p>
</blockquote>
<p>问: 如何保证磁盘中的数据在断电或者系统宕机之后还能保持一致?</p>
<blockquote>
<p>答: 磁盘数据写入是一个事务, 包括多个操作, 写头信息, 写入数据等, 需要保证事务的原子性. 那么问题的实质是如何实现一个磁盘更新的事务.</p>
<p>实现一: 定时扫描磁盘, 如果发现有不一致的状态, 然后修复. 缺点是太慢了</p>
<p>实现二: 提前写日志, 如果系统宕机, 那么可以从日志中得到足够的信息恢复</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李宏杰</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李宏杰</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
